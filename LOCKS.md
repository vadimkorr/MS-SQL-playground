# Locks

## Table of contents
* [Lock modes](#lock-modes)
* [Lock granularity](#lock-granularity)
* [Lock escalation](#lock-escalation)
* [Deadlock](#deadlock)


Одновременный конкурентный доступ может вызывать разные трицательные эффекты (напрмер, грязное чтение).

Для обеспечения согласованности данных в случае одновремнного обращения к данным несколькими пользователями Database Engine применяет блокировки. Каждая прикладная программа юлокирует требуемые ей данные, что гаррантирует, что никакая другая программа не сможет модифицировать эти данные. Когда другая прикладная программа пытается получить доступ к заблокированным данным для их модификации, то система или завершает эту попытку ошибкой, или заставляет программу ожидать снятия блокировку. 

Блокировка имеет несколько разных свойств:
* длительность - период, в течение которого ресурс удерживает блокировку. Длительность зависит от режима блокировки и выбора уровня блокировки. 
* режим
* гранулярность

## **Lock modes**
Выбор режима блокировки зависит от типа ресурса, который требуется заблокировать. Для блокировок ресурсов **уровня строки и страницы** применяются следующие типы блокировок. (Система БД автоматически выбирает соответствующий режим блокировки в зависимости от типа операции)
* разделяемая (shared, S) - резервирует ресурс только для чтения. Другие процессы не могут изменять заблокированный таким образом ресурс. Но, несколько процессов могут одновременно накладывать разделяемую блокировку на один и тот же ресурс. 
* монопольная (exclusive, X) - резервирует ресурс для монопольного использования одной транзакции. (`INSERT`, `UPDATE`, `DELETE`)
* блокировка обновления (update, U) - применяется для предотвращения распространенных типов взаимоблокировок.
* другие типы блокировок: кратковременная (latch lock), взаимоблокировка (spin lock)

**На уровне таблицы**:
* разделяемая (shared, S)
* монопольная (exclusive, X)
* разделяемая с намерением (intent shared, IS)
* монопольная с намерением (intent exclusive, IX)
* разделяемая с монопольным намерением (shared with intent exclusive, SIX)

блокировка с намерпением означает, что транзакция намеревается блокировать следующий нижележащий в иерархии объектов БД ресурс. Таким образом, блокировка с намерением помещается на уровне иерархии объектов, который выше того объекта, который этот процесс намеревается заблокировать. 

## **Lock granularity**
Определяет, какой ресурс блокируется в одной попытке блокировки. Система выбирает требуемую гранулярность блокировки автоматически. 
* строки
* страницы
* индексный ключ или диапазон индексных ключей
* таблицы
* экстент - единицы дискового пространства, имеют размер 64Кб
* саму БД

Низкий уровень блокировки увеличивает системные накладные расходы, т.к. для каждой отдельной строки требуется отдельная блокировка. Блокировка на уровне страниц и таблиц ограничивает уровень доступности данных, но также уменьшает системные накладные ресурсы.

## **Lock escalation**
Если в процессе транзакции имеется большое количество блокировок одного уровня, то Database Engine автоматически объединяет эти блокировки в одну уровня таблицы. Порогом укрупнения называется граница, на которой система БД прмименяет укрупнение блокировок. 

Механизм укрупнения блокировок можно модифицировать с помощью инструкции `ALTER TABLE`. 

```sql
SET (LOCK_ESCALATION = { TABLE | AUTO | DISABLE })
--
ALTER TABLE employee SET (LOCK_ESCALATION = DISABLE);
``` 
Настройку блокировок можно осуществить, используя подсказки блокировок или параметр `LOCK_TIMEOUT` инструкции `SET`. Чтобы процесс не ожидал освобождения блокируемого объекта до бесконечности, можно указать таймаут в миллисекундах.

## **Deadlock**
одновременный конкурентный доступ, в которой две транзакции блокируют друг друга. (В частности, первая транзакция блокирует объект БД, доступ к которому хочет получить другая транзакция)

```sql
BEGIN TRANSACTION
UPDATE works_on 
    SET job='Manager'
    WHERE emp_no=18316
    AND project_no='p2'
WAITFOR DELAY '00:00:10'
UPDATE employee
    SET emp_lname='Green'
    WHERE emp_no=9031
COMMIT

--

BEGIN TRANSACTION
UPDATE employee
    SET dept_no='d2'
    WHERE emp_no=9031
WAITFOR DELAY '00:00:10'
DELETE FROM works_on
    WHERE emp_no=18316
    AND project_no='p2'
COMMIT
```

